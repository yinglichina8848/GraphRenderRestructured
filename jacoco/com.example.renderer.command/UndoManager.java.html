<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UndoManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GraphRenderSystem</a> &gt; <a href="index.source.html" class="el_package">com.example.renderer.command</a> &gt; <span class="el_source">UndoManager.java</span></div><h1>UndoManager.java</h1><pre class="source lang-java linenums">/**
 * UndoManager管理命令的撤销和重做操作，使用栈结构保存命令历史。
 * 
 * &lt;p&gt;实现了命令模式中的命令管理器角色，支持：
 * &lt;ul&gt;
 *   &lt;li&gt;执行命令并保存到撤销栈&lt;/li&gt;
 *   &lt;li&gt;撤销最近执行的命令&lt;/li&gt;
 *   &lt;li&gt;重做最近撤销的命令&lt;/li&gt;
 *   &lt;li&gt;检查是否可以撤销/重做&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;典型用法：
 * &lt;pre&gt;{@code
 * UndoManager undoManager = new UndoManager();
 * Command cmd = new AddShapeCommand(shapes, new Circle(10,10,5));
 * undoManager.executeCommand(cmd); // 执行并保存命令
 * if (undoManager.canUndo()) {
 *     undoManager.undo(); // 撤销命令
 * }
 * if (undoManager.canRedo()) {
 *     undoManager.redo(); // 重做命令
 * }
 * }&lt;/pre&gt;
 *
 * @author DeepSeek-Coder
 * @version 1.0
 * @see Command 命令接口
 * @see AddShapeCommand 添加图形命令
 * @see MoveShapeCommand 移动图形命令
 * @since 2025-06-24
 */
package com.example.renderer.command;

import java.util.Stack;
import java.util.Objects;

/**
 * 撤销管理器，管理命令的撤销和重做操作
 */
<span class="fc" id="L40">public class UndoManager {</span>
<span class="fc" id="L41">    private final Stack&lt;Command&gt; undoStack = new Stack&lt;&gt;();</span>
<span class="fc" id="L42">    private final Stack&lt;Command&gt; redoStack = new Stack&lt;&gt;();</span>
<span class="fc" id="L43">    private int maxHistorySize = 100; // 默认最大历史记录数</span>

    /**
     * 设置最大历史记录数
     * @param size 最大历史记录数
     */
    public void setMaxHistorySize(int size) {
<span class="fc" id="L50">        this.maxHistorySize = size;</span>
<span class="fc" id="L51">    }</span>

    /**
     * 清除所有历史记录
     */
    public void clearHistory() {
<span class="fc" id="L57">        undoStack.clear();</span>
<span class="fc" id="L58">        redoStack.clear();</span>
<span class="fc" id="L59">    }</span>

    /**
     * 执行命令并保存到撤销栈。
     * 
     * @param cmd 要执行的命令(非null)
     * @author Aider+DeepSeek
     * @since 2025-06-24
     */
    /**
     * 执行命令并保存到撤销栈。
     * 
     * @param cmd 要执行的命令(非null)
     * @throws NullPointerException 如果cmd参数为null
     * @author Aider+DeepSeek
     * @since 2025-06-24
     */
    public void executeCommand(Command cmd) {
<span class="fc" id="L77">        Objects.requireNonNull(cmd, &quot;Command cannot be null&quot;);</span>
<span class="fc" id="L78">        cmd.execute();</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">        if (undoStack.size() &gt;= maxHistorySize) {</span>
<span class="fc" id="L80">            undoStack.remove(0); // 移除最旧的命令</span>
        }
<span class="fc" id="L82">        undoStack.push(cmd);</span>
<span class="fc" id="L83">        redoStack.clear();</span>
<span class="fc" id="L84">    }</span>

    /**
     * 撤销最近执行的命令。
     * 
     * @author Aider+DeepSeek
     * @since 2025-06-24
     */
    public void undo() {
<span class="fc bfc" id="L93" title="All 2 branches covered.">        if (!undoStack.isEmpty()) {</span>
<span class="fc" id="L94">            Command cmd = undoStack.pop();</span>
<span class="fc" id="L95">            cmd.undo();</span>
<span class="fc" id="L96">            redoStack.push(cmd);</span>
        }
<span class="fc" id="L98">    }</span>

    /**
     * 重做最近撤销的命令。
     * 
     * @author Aider+DeepSeek
     * @since 2025-06-24
     */
    public void redo() {
<span class="fc bfc" id="L107" title="All 2 branches covered.">        if (!redoStack.isEmpty()) {</span>
<span class="fc" id="L108">            Command cmd = redoStack.pop();</span>
<span class="fc" id="L109">            cmd.execute();</span>
<span class="fc" id="L110">            undoStack.push(cmd);</span>
        }
<span class="fc" id="L112">    }</span>

    /**
     * 检查是否可以执行撤销操作。
     * 
     * @return 如果撤销栈不为空返回true，否则返回false
     * @author Aider+DeepSeek
     * @since 2025-06-24
     */
    public boolean canUndo() {
<span class="fc bfc" id="L122" title="All 2 branches covered.">        return !undoStack.isEmpty();</span>
    }

    /**
     * 检查是否可以执行重做操作。
     * 
     * @return 如果重做栈不为空返回true，否则返回false
     * @author Aider+DeepSeek
     * @since 2025-06-24
     */
    public boolean canRedo() {
<span class="fc bfc" id="L133" title="All 2 branches covered.">        return !redoStack.isEmpty();</span>
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>