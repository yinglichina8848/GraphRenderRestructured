<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RuntimeTypeAdapterFactory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GraphRenderSystem</a> &gt; <a href="index.source.html" class="el_package">com.example.renderer.util</a> &gt; <span class="el_source">RuntimeTypeAdapterFactory.java</span></div><h1>RuntimeTypeAdapterFactory.java</h1><pre class="source lang-java linenums">package com.example.renderer.util;

/**
 * RuntimeTypeAdapterFactory是Gson的类型适配器工厂，支持运行时多态类型的序列化/反序列化。
 * 解决Gson默认不支持多态类型的问题，通过类型字段(typeFieldName)来区分具体子类。
 *
 * &lt;p&gt;工作原理：
 * &lt;ol&gt;
 *   &lt;li&gt;序列化时添加类型标识字段&lt;/li&gt;
 *   &lt;li&gt;反序列化时根据类型标识字段创建对应子类实例&lt;/li&gt;
 * &lt;/ol&gt;
 * &lt;/p&gt;
 *
 * &lt;p&gt;典型用法：
 * &lt;pre&gt;{@code
 * RuntimeTypeAdapterFactory&lt;Shape&gt; adapterFactory = 
 *     RuntimeTypeAdapterFactory.of(Shape.class, &quot;type&quot;)
 *         .registerSubtype(Circle.class, &quot;circle&quot;)
 *         .registerSubtype(Rectangle.class, &quot;rectangle&quot;);
 *
 * Gson gson = new GsonBuilder()
 *     .registerTypeAdapterFactory(adapterFactory)
 *     .create();
 * }&lt;/pre&gt;
 * &lt;/p&gt;
 *
 * &lt;p&gt;注意事项：
 * &lt;ul&gt;
 *   &lt;li&gt;类型字段名称(typeFieldName)必须在JSON中唯一&lt;/li&gt;
 *   &lt;li&gt;所有子类必须提前注册&lt;/li&gt;
 *   &lt;li&gt;子类需要有无参构造函数&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/p&gt;
 *
 * @see &lt;a href=&quot;https://github.com/google/gson/blob/master/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java&quot;&gt;
 *     Gson官方类似实现&lt;/a&gt;
 * @see Gson Google的JSON处理库
 * @author liying
 * @since 1.0
 * @version 1.0
 */

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.google.gson.internal.Streams;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

/**
 * 运行时类型适配器工厂类
 * @param &lt;T&gt; 基类型
 */
public class RuntimeTypeAdapterFactory&lt;T&gt; implements TypeAdapterFactory {
    private final Class&lt;?&gt; baseType;
    private final String typeFieldName;
<span class="fc" id="L65">    private final Map&lt;String, Class&lt;?&gt;&gt; labelToSubtype = new HashMap&lt;&gt;();</span>
<span class="fc" id="L66">    private final Map&lt;Class&lt;?&gt;, String&gt; subtypeToLabel = new HashMap&lt;&gt;();</span>

<span class="fc" id="L68">    private RuntimeTypeAdapterFactory(Class&lt;?&gt; baseType, String typeFieldName) {</span>
<span class="fc" id="L69">        this.baseType = baseType;</span>
<span class="fc" id="L70">        this.typeFieldName = typeFieldName;</span>
<span class="fc" id="L71">    }</span>

    /**
     * 创建运行时类型适配器工厂
     * 
     * @param &lt;T&gt; 基类型
     * @param baseType 基类
     * @param typeFieldName JSON中的类型字段名
     * @return 适配器工厂实例
     */
    public static &lt;T&gt; RuntimeTypeAdapterFactory&lt;T&gt; of(Class&lt;T&gt; baseType, String typeFieldName) {
<span class="fc" id="L82">        return new RuntimeTypeAdapterFactory&lt;&gt;(baseType, typeFieldName);</span>
    }

    /**
     * 注册子类型
     * 
     * @param type 子类型类对象
     * @param label 类型标签
     * @return 适配器工厂实例(用于链式调用)
     */
    public RuntimeTypeAdapterFactory&lt;T&gt; registerSubtype(Class&lt;? extends T&gt; type, String label) {
<span class="fc" id="L93">        labelToSubtype.put(label, type);</span>
<span class="fc" id="L94">        subtypeToLabel.put(type, label);</span>
<span class="fc" id="L95">        return this;</span>
    }

    @Override
    public &lt;R&gt; TypeAdapter&lt;R&gt; create(Gson gson, TypeToken&lt;R&gt; type) {
<span class="fc bfc" id="L100" title="All 2 branches covered.">        if (!baseType.isAssignableFrom(type.getRawType())) {</span>
<span class="fc" id="L101">            return null;</span>
        }

<span class="fc" id="L104">        final Map&lt;String, TypeAdapter&lt;?&gt;&gt; labelToDelegate = new HashMap&lt;&gt;();</span>
<span class="fc" id="L105">        final Map&lt;Class&lt;?&gt;, TypeAdapter&lt;?&gt;&gt; subtypeToDelegate = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L107" title="All 2 branches covered.">        for (Map.Entry&lt;String, Class&lt;?&gt;&gt; entry : labelToSubtype.entrySet()) {</span>
<span class="fc" id="L108">            TypeAdapter&lt;?&gt; delegate = gson.getDelegateAdapter(this, TypeToken.get(entry.getValue()));</span>
<span class="fc" id="L109">            labelToDelegate.put(entry.getKey(), delegate);</span>
<span class="fc" id="L110">            subtypeToDelegate.put(entry.getValue(), delegate);</span>
<span class="fc" id="L111">        }</span>

<span class="fc" id="L113">        return new TypeAdapter&lt;R&gt;() {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
            @Override
            public void write(JsonWriter out, R value) throws IOException {
<span class="fc" id="L117">                Class&lt;?&gt; srcType = value.getClass();</span>
<span class="fc" id="L118">                String label = subtypeToLabel.get(srcType);</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">                if (label == null) {</span>
<span class="nc" id="L120">                    throw new JsonParseException(&quot;Cannot serialize &quot; + srcType.getName());</span>
                }
<span class="fc" id="L122">                TypeAdapter&lt;R&gt; delegate = (TypeAdapter&lt;R&gt;) subtypeToDelegate.get(srcType);</span>
<span class="fc" id="L123">                JsonObject jsonObject = delegate.toJsonTree(value).getAsJsonObject();</span>
<span class="fc" id="L124">                jsonObject.addProperty(typeFieldName, label);</span>
<span class="fc" id="L125">                Streams.write(jsonObject, out);</span>
<span class="fc" id="L126">            }</span>

            @SuppressWarnings(&quot;unchecked&quot;)
            @Override
            public R read(JsonReader in) throws IOException {
<span class="fc" id="L131">                JsonElement jsonElement = Streams.parse(in);</span>
<span class="fc" id="L132">                JsonObject jsonObject = jsonElement.getAsJsonObject();</span>
<span class="fc" id="L133">                JsonElement labelJsonElement = jsonObject.remove(typeFieldName);</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">                if (labelJsonElement == null) {</span>
<span class="nc" id="L135">                    throw new JsonParseException(&quot;Cannot deserialize missing type field: &quot; + typeFieldName);</span>
                }
<span class="fc" id="L137">                String label = labelJsonElement.getAsString();</span>
<span class="fc" id="L138">                TypeAdapter&lt;?&gt; delegate = labelToDelegate.get(label);</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">                if (delegate == null) {</span>
<span class="nc" id="L140">                    throw new JsonParseException(&quot;Unknown label: &quot; + label);</span>
                }
<span class="fc" id="L142">                return (R) delegate.fromJsonTree(jsonObject);</span>
            }
        };
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>