<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>design-specification2</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">design-specification2</h1>
</header>
<p>┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ 架构设计规范 ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛</p>
<ol type="1">
<li>文档概述</li>
</ol>
<p>本文档定义了图形渲染系统的架构设计规范和标准，确保系统开发遵循统一的设计原则和最佳实践。</p>
<ol start="2" type="1">
<li>设计原则</li>
</ol>
<p>2.1 核心原则</p>
<p>1 单一职责原则 (SRP)<br />
• 每个类/模块只承担一个明确的职责<br />
• 示例：Renderer只负责渲染，Shape只定义图形属性<br />
2 开闭原则 (OCP)<br />
• 通过扩展而非修改来增加新功能<br />
• 示例：通过实现Renderer接口添加新渲染器<br />
3 依赖倒置原则 (DIP)<br />
• 高层模块不依赖低层模块，都依赖抽象<br />
• 示例：UI层通过Renderer接口使用渲染功能</p>
<p>2.2 补充原则</p>
<p>1 最少知识原则<br />
• 模块只与直接朋友通信<br />
• 示例：Command不需要知道DrawingPanel内部实现<br />
2 约定优于配置<br />
• 采用合理的默认值减少配置<br />
• 示例：RendererFactory内置默认渲染器</p>
<ol start="3" type="1">
<li>分层规范</li>
</ol>
<p>3.1 层次定义</p>
<p>层级 组件示例 职责 允许依赖<br />
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
表现层 SwingUI, DrawingPanel 用户交互和展示 业务逻辑层<br />
业务逻辑层 Command, UndoManager 核心业务流程 服务层、领域层<br />
服务层 RendererFactory, ShapeFactory 技术服务提供 领域层<br />
领域层 Shape, Renderer 核心业务模型 无<br />
基础设施层 PersistenceManager 技术实现细节 被各层依赖</p>
<p>3.2 层间通信规则</p>
<p>1 严格分层：只允许上层调用下层<br />
2 跨层调用：必须通过接口抽象<br />
3 数据传递：使用DTO而非领域对象跨层</p>
<ol start="4" type="1">
<li>模块设计规范</li>
</ol>
<p>4.1 模块划分标准</p>
<p>1 功能内聚：相关功能放在同一模块<br />
• 示例：所有渲染器实现在bridge模块<br />
2 变更隔离：可能同时变更的内容放在一起<br />
• 示例：legacy模块隔离旧版代码<br />
3 复用粒度：按复用需求划分模块<br />
• 示例：core模块包含可复用基础设施</p>
<p>4.2 模块依赖规则</p>
<p>graph TD<br />
ui –&gt; core<br />
ui –&gt; bridge<br />
command –&gt; core<br />
bridge –&gt; legacy<br />
factory –&gt; core<br />
persistence –&gt; factory</p>
<ol start="5" type="1">
<li>接口设计规范</li>
</ol>
<p>5.1 接口定义要求</p>
<p>1 明确职责：</p>
<p>/**<br />
* 图形渲染接口<br />
* <span class="citation" data-cites="implSpec">@implSpec</span>
实现类必须保证线程安全<br />
*/<br />
public interface Renderer {<br />
void drawCircle(int x, int y, int radius);<br />
}</p>
<p>2 参数校验：</p>
<p>default void drawCircle(int x, int y, int radius) {<br />
Objects.requireNonNull(renderer);<br />
if (radius &lt;= 0) throw new IllegalArgumentException();<br />
// 实际实现<br />
}</p>
<p>5.2 接口演化策略</p>
<p>1 新增方法：使用默认实现保持兼容<br />
2 方法弃用：用@Deprecated标注并说明替代方案<br />
3 重大变更：创建新接口版本</p>
<ol start="6" type="1">
<li>类设计规范</li>
</ol>
<p>6.1 类职责矩阵</p>
<p>类别 示例 职责数量 方法数量 属性数量<br />
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 控制类
UndoManager 1 5-10 2-5<br />
实体类 Circle 1 5-8 3-6<br />
服务类 RendererFactory 1 3-5 1-3</p>
<p>6.2 类设计约束</p>
<p>1 不可变性：值对象应设计为不可变</p>
<p>public final class Point {<br />
private final int x;<br />
private final int y;<br />
// 只有getter方法<br />
}</p>
<p>2 构造规范：<br />
• 避免过长参数列表（≤5个）<br />
• 复杂对象使用Builder模式</p>
<ol start="7" type="1">
<li>设计模式应用规范</li>
</ol>
<p>7.1 模式选用标准</p>
<p>场景 首选模式 替代方案 禁用情况<br />
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 对象创建 工厂方法 简单工厂
直接new<br />
行为扩展 访问者 策略 继承<br />
状态管理 备忘录 状态 标志位</p>
<p>7.2 模式实现模板</p>
<p>工厂方法示例：</p>
<p>public interface RendererFactory {<br />
// 标准工厂方法<br />
Renderer create();</p>
<pre><code>// 带参数的变体                                                                                                                 
Renderer create(String config);                                                                                                 </code></pre>
<p>}</p>
<p>命令模式示例：</p>
<p>public abstract class AbstractCommand implements Command {<br />
protected final List<Shape> shapes;</p>
<pre><code>// 模板方法                                                                                                                     
public final void execute() {                                                                                                   
    if (!canExecute()) throw new IllegalStateException();                                                                       
    doExecute();                                                                                                                
}                                                                                                                               
                                                                                                                                
protected abstract void doExecute();                                                                                            </code></pre>
<p>}</p>
<ol start="8" type="1">
<li>异常处理规范</li>
</ol>
<p>8.1 异常分类</p>
<p>类型 示例 处理方式<br />
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 业务异常
InvalidShapeException 展示给用户<br />
系统异常 RenderingException 日志记录后恢复<br />
致命错误 OutOfMemoryError 终止应用</p>
<p>8.2 异常处理模板</p>
<p>try {<br />
renderer.drawShape(shape);<br />
} catch (RenderingException e) {<br />
LOGGER.error(“渲染失败”, e);<br />
fallbackRenderer.drawPlaceholder();<br />
} finally {<br />
renderer.cleanup();<br />
}</p>
<ol start="9" type="1">
<li>性能设计规范</li>
</ol>
<p>9.1 性能敏感场景</p>
<p>1 渲染循环：</p>
<p>// 避免在渲染循环中创建对象<br />
for (Shape shape : shapes) {<br />
shape.render(reusedRenderer);<br />
}</p>
<p>2 内存缓存：</p>
<p>public class ShapeCache {<br />
private static final int MAX_SIZE = 100;<br />
private static LinkedHashMap&lt;Key, Shape&gt; cache =<br />
new LinkedHashMap&lt;&gt;(…, 0.75f, true) {<br />
protected boolean removeEldestEntry(Map.Entry eldest) {<br />
return size() &gt; MAX_SIZE;<br />
}<br />
};<br />
}</p>
<p>9.2 并发控制</p>
<p>1 线程安全级别：</p>
<p><span class="citation"
data-cites="ThreadSafe">@ThreadSafe</span><br />
public class GlobalConfig {<br />
// 使用volatile保证可见性<br />
private volatile String renderMode;<br />
}</p>
<p>2 锁粒度控制：</p>
<p>public class ThreadSafeRenderer implements Renderer {<br />
private final Object lock = new Object();</p>
<pre><code>   public void drawCircle(...) {                                                                                                
       synchronized(lock) {                                                                                                     
           // 关键区代码                                                                                                        
       }                                                                                                                        
   }                                                                                                                            </code></pre>
<p>}</p>
<ol start="10" type="1">
<li>文档化规范</li>
</ol>
<p>10.1 代码注释标准</p>
<p>1 类注释：</p>
/**<br />
* 圆形图形实现<br />
*<br />
*
<p>
<b>线程安全：</b>此类是不可变对象，线程安全
</p>
<pre><code>*                                                                                                                               
* @see Shape 基础接口                                                                                                           
* @since 2.0                                                                                                                    
*/                                                                                                                              </code></pre>
<p>public final class Circle implements Shape {</p>
<p>2 方法注释：</p>
<p>/**<br />
* 绘制圆形<br />
* <span class="citation" data-cites="param">@param</span> radius
半径(必须&gt;0)<br />
* <span class="citation" data-cites="throws">@throws</span>
IllegalArgumentException 如果半径≤0<br />
* <span class="citation" data-cites="throws">@throws</span>
RenderingException 当底层渲染失败时<br />
*/<br />
public void drawCircle(int radius) {</p>
<p>10.2 设计决策记录</p>
<p>1 ADR模板：</p>
<p># 1. 使用适配器模式整合旧版渲染器</p>
<p>## 状态<br />
已采纳</p>
<p>## 决策因素<br />
- 需要支持遗留系统<br />
- 最小化修改现有代码<br />
- 20%性能开销可接受</p>
<p>## 替代方案<br />
1. 直接重写旧版代码（高风险）<br />
2. 并行维护两套系统（高成本）</p>
<p>附录A：架构质量检查表</p>
<p>1 [ ] 所有模块依赖关系符合分层规范<br />
2 [ ] 关键接口有明确的@implSpec说明<br />
3 [ ] 性能敏感代码经过Profiler验证<br />
4 [ ] 异常处理覆盖所有已知错误场景<br />
5 [ ] 设计决策已记录在ADR文档中</p>
<p>附录B：参考架构</p>
<p>🌆 参考架构图</p>
<p>版本控制：</p>
<p>• v1.0 2025-06-20 初始版本<br />
• v1.1 2025-06-25 添加性能设计规范<br />
• v2.0 2025-06-27 重构分层规范</p>
<p>归档位置：docs/architecture/design-specification.md</p>
</body>
</html>
